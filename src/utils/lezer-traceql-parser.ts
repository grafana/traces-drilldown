/**
 * Lezer-based TraceQL parser for extracting filters from raw TraceQL queries.
 * This parser uses the official @grafana/lezer-traceql parser for accurate
 * syntax tree parsing and leverages helper functions from Tempo datasource
 * for consistent filter processing.
 * 
 * SCOPE AND PURPOSE:
 * This parser is specifically designed for link generation in traces-drilldown.
 * It extracts spanset filters that can be represented as URL parameters.
 * 
 * DESIGN PRINCIPLE: Complete compatibility with Tempo Query Builder output.
 * The parser supports all TraceQL queries that the Tempo Query Builder UI can generate,
 * ensuring that any query created through the official Tempo interface will work
 * correctly with traces-drilldown navigation. This is a subset of valid TraceQL syntax.
 * 
 * ✅ FULLY SUPPORTED (All Tempo Query Builder generated patterns):
 * 
 * Basic Filters:
 * - Single filters: {service.name="frontend"}
 * - Multiple filters with AND: {service.name="frontend" && status=error}
 * - All scopes: resource.*, span.*, event.*, instrumentation.*, link.*, intrinsic, unscoped.*
 * - All comparison operators: =, !=, >, <, >=, <=, =~, !~
 * - Duration types: {duration>100ms} or {traceDuration>1s} (based on UI selection)
 * 
 * Multiple Values (OR within same field):
 * - String values: (service.name="frontend" || service.name="backend")
 * - Non-string values: (span.http.status_code=200 || span.http.status_code=404)
 * - Regex with multiple values: service.name=~"frontend|backend"
 * - Generated by: Query Builder's filterToQuerySection() when filter.value is array
 * 
 * Complex Combinations:
 * - Mixed scopes: {resource.cluster="prod" && span.http.method="GET" && duration>100ms}
 * - Multiple spansets: {service="A"} && {span.http.status=200}
 * 
 * ❌ NOT SUPPORTED (Valid TraceQL but Query Builder CANNOT generate):
 * 
 * - OR between different fields: {service.name="A"} || {status=error}
 *   Reason: Query Builder only creates TraceqlFilter[] combined with && logic
 * 
 * - Structural operators: {parent} > {child}, {ancestor} >> {descendant}
 *   Reason: No Query Builder UI for span relationships
 * 
 * - Pipeline aggregations: {filters} | count() > 5
 *   Reason: Query Builder focuses on filtering, not aggregation
 * 
 * - Union operators: &>, &>>, &<<, &<, &~
 *   Reason: No Query Builder support for complex span relationships
 * 
 * The parser gracefully handles unsupported syntax by extracting only the
 * filter components that can be meaningfully represented in URL parameters.
 */

import { SyntaxNode, SyntaxNodeRef } from '@lezer/common';
import {
  AttributeField,
  FieldExpression,
  FieldOp,
  IntrinsicField,
  parser,
  SpansetFilter,
  Static,
} from '@grafana/lezer-traceql';

import { TraceqlFilter } from './links';

export interface TraceQLParseResult {
  filters: TraceqlFilter[];
  errors: TraceQLParseError[];
}

export interface TraceQLParseError {
  type: 'unsupported_or_between_fields' | 'unsupported_structural_operator' | 'unsupported_pipeline' | 'unsupported_union_operator';
  message: string;
  query: string;
}

// Valid scopes for TraceQL fields - copied from Tempo
const VALID_SCOPES = ['resource', 'span', 'event', 'instrumentation', 'link'];

// Common intrinsic field patterns - copied from Tempo
const INTRINSIC_FIELDS = [
  'duration', 'kind', 'name', 'status', 'statusMessage', 'traceDuration',
  'rootName', 'rootServiceName',
  'event:name', 'event:timeSinceStart',
  'instrumentation:name', 'instrumentation:version',
  'link:spanID', 'link:traceID',
  'span:duration', 'span:id', 'span:kind', 'span:name', 'span:parentID', 
  'span:status', 'span:statusMessage',
  'trace:duration', 'trace:id', 'trace:rootName', 'trace:rootService'
];

/**
 * Extract filters from a raw TraceQL query string using the Lezer parser.
 * This provides more accurate parsing than regex-based approaches.
 * 
 * @param query - Raw TraceQL query string
 * @returns Object with filters array and errors array, or null if parsing fails completely
 */
export function parseTraceQLQuery(query: string): TraceQLParseResult | null {
  if (!query || typeof query !== 'string') {
    return null;
  }

  const cleanQuery = query.trim();
  if (!cleanQuery) {
    return null;
  }

  try {
    const tree = parser.parse(cleanQuery);
    const filters: TraceqlFilter[] = [];
    const errors: TraceQLParseError[] = [];

    // Walk the syntax tree to find ALL SpansetFilter nodes
    const allSpansetFilters: SyntaxNode[] = [];
    tree.iterate({
      enter: (nodeRef: SyntaxNodeRef) => {
        if (nodeRef.type.id === SpansetFilter) {
          allSpansetFilters.push(nodeRef.node);
        }
      },
    });

    // Check for OR between different spansets (unsupported pattern)
    if (allSpansetFilters.length > 1) {
      // Check if this is an OR pattern by looking for OR operators between spansets
      const hasOrBetweenSpansets = checkForOrBetweenSpansets(tree, cleanQuery);
      if (hasOrBetweenSpansets) {
        errors.push({
          type: 'unsupported_or_between_fields',
          message: 'OR between different spansets is not supported. Using first spanset only. Original query semantics (OR) will be lost and converted to AND logic.',
          query: cleanQuery
        });
        
        // Extract only the first spanset to avoid changing OR to AND
        const firstSpansetFilters = extractFiltersFromSpanset(allSpansetFilters[0], cleanQuery);
        filters.push(...firstSpansetFilters);
      } else {
        // This is AND between spansets (Query Builder pattern) - process all
        for (const spansetNode of allSpansetFilters) {
          const spansetFilters = extractFiltersFromSpanset(spansetNode, cleanQuery);
          filters.push(...spansetFilters);
        }
      }
    } else {
      // Single spanset - process normally
      for (const spansetNode of allSpansetFilters) {
        const spansetFilters = extractFiltersFromSpanset(spansetNode, cleanQuery);
        filters.push(...spansetFilters);
      }
    }

    // Check for other unsupported patterns and add appropriate errors
    checkForUnsupportedPatterns(tree, cleanQuery, errors);

    // Combine filters with same scope/tag/operator into single filters with array values
    // This handles Query Builder's OR logic: (field=val1 || field=val2)
    // See: SearchTraceQLEditor/utils.ts lines 83-84 in filterToQuerySection function
    const combinedFilters = combineFiltersWithSameField(filters);

    // Return null if no filters found and no errors (empty query)
    if (combinedFilters.length === 0 && errors.length === 0) {
      return null;
    }

    return {
      filters: combinedFilters,
      errors
    };
  } catch (error) {
    // If parsing fails completely, return null to fallback gracefully
    return null;
  }
}

/**
 * Extract all filters from a spanset node.
 */
function extractFiltersFromSpanset(spansetNode: SyntaxNode, query: string): TraceqlFilter[] {
  const filters: TraceqlFilter[] = [];
  const processedNodes = new Set<number>(); // Track processed nodes to avoid duplicates

  // Recursively find all FieldExpression nodes within this spanset
  function findFieldExpressions(node: SyntaxNode) {
    // Skip if already processed
    if (processedNodes.has(node.from)) {
      return;
    }

    if (node.type.id === FieldExpression) {
      // Check if this FieldExpression has the structure we want (field = value)
      if (hasFieldOperatorValueStructure(node)) {
        const filter = extractFilterFromFieldExpression(node, query);
        if (filter) {
          filters.push(filter);
          processedNodes.add(node.from);
        }
      } else {
        // Check if this is a simple field=value expression (without nested structure)
        const filter = extractSimpleFieldExpression(node, query);
        if (filter) {
          filters.push(filter);
          processedNodes.add(node.from);
        }
      }
    }

    // Also check for error cases where field name is split
    // This handles cases like "service.name=~..." where "service" becomes an error node
    if (node.type.id === 0) { // Error node
      // Check if there's a FieldExpression sibling that might be the rest of the expression
      const parent = node.parent;
      if (parent && parent.type.id === SpansetFilter) {
        const errorText = getNodeText(node, query);
        const nextSibling = node.nextSibling;
        
        if (nextSibling && nextSibling.type.id === FieldExpression && !processedNodes.has(nextSibling.from)) {
          // Try to reconstruct the full field expression
          const siblingText = getNodeText(nextSibling, query);
          const fullExpression = errorText + siblingText;
          
          // Try to parse this as a complete filter using regex fallback
          const regexFilter = parseWithRegexFallback(fullExpression);
          if (regexFilter) {
            filters.push(regexFilter);
            processedNodes.add(node.from);
            processedNodes.add(nextSibling.from); // Mark sibling as processed too
            return; // Don't process the sibling again
          }
        }
      }
    }

    // Recursively check children
    const cursor = node.cursor();
    if (cursor.firstChild()) {
      do {
        findFieldExpressions(cursor.node);
      } while (cursor.nextSibling());
    }
  }

  findFieldExpressions(spansetNode);
  return filters;
}

/**
 * Check if a FieldExpression has the structure: field operator value
 * Based on the debug output, the structure is:
 * FieldExpression -> [FieldExpression(field), FieldOp, FieldExpression(value)]
 */
function hasFieldOperatorValueStructure(node: SyntaxNode): boolean {
  let hasFieldExpression = 0;
  let hasOperator = false;

  const cursor = node.cursor();
  if (cursor.firstChild()) {
    do {
      const child = cursor.node;
      if (child.type.id === FieldExpression) {
        hasFieldExpression++;
      } else if (child.type.id === FieldOp) {
        hasOperator = true;
      }
    } while (cursor.nextSibling());
  }

  // We expect exactly 2 FieldExpressions (field and value) and 1 FieldOp
  return hasFieldExpression === 2 && hasOperator;
}

/**
 * Extract a simple field expression that has direct field, operator, value children.
 * This handles cases like individual conditions in OR expressions.
 */
function extractSimpleFieldExpression(node: SyntaxNode, query: string): TraceqlFilter | null {
  let fieldNode: SyntaxNode | null = null;
  let operatorNode: SyntaxNode | null = null;
  let valueNode: SyntaxNode | null = null;

  // Walk through direct children
  const cursor = node.cursor();
  if (cursor.firstChild()) {
    do {
      const child = cursor.node;
      if (child.type.id === IntrinsicField || child.type.id === AttributeField) {
        fieldNode = child;
      } else if (child.type.id === FieldOp) {
        operatorNode = child;
      } else if (child.type.id === Static) {
        valueNode = child;
      }
    } while (cursor.nextSibling());
  }

  if (!fieldNode || !operatorNode || !valueNode) {
    return null;
  }

  // Extract text content from nodes
  const fieldText = getNodeText(fieldNode, query);
  const operatorText = getNodeText(operatorNode, query);
  const valueText = getNodeText(valueNode, query);

  // Parse field into scope and tag
  const { scope, tag } = parseField(fieldText);
  if (!tag) {
    return null;
  }

  // Parse value (handle quotes and escaping)
  const value = parseValue(valueText);
  if (value === null) {
    return null;
  }

  return {
    scope,
    tag,
    operator: operatorText,
    value,
  };
}

/**
 * Extract a single filter from a FieldExpression node.
 * The structure is: FieldExpression -> [FieldExpression(field), FieldOp, FieldExpression(value)]
 */
function extractFilterFromFieldExpression(node: SyntaxNode, query: string): TraceqlFilter | null {
  let fieldText = '';
  let operatorText = '';
  let valueText = '';

  // Walk through direct children
  const cursor = node.cursor();
  if (cursor.firstChild()) {
    do {
      const child = cursor.node;
      if (child.type.id === FieldExpression) {
        // This could be either the field or the value FieldExpression
        const childText = getNodeText(child, query);
        
        // Check if this FieldExpression contains an AttributeField or IntrinsicField
        if (containsField(child)) {
          fieldText = childText;
        } else if (containsValue(child)) {
          valueText = childText;
        }
      } else if (child.type.id === FieldOp) {
        operatorText = getNodeText(child, query);
      }
    } while (cursor.nextSibling());
  }

  if (!fieldText || !operatorText || !valueText) {
    return null;
  }

  // Parse field into scope and tag
  const { scope, tag } = parseField(fieldText);
  if (!tag) {
    return null;
  }

  // Parse value (handle quotes and escaping)
  const value = parseValue(valueText);
  if (value === null) {
    return null;
  }

  return {
    scope,
    tag,
    operator: operatorText,
    value,
  };
}

/**
 * Check if a node contains a field (AttributeField or IntrinsicField)
 */
function containsField(node: SyntaxNode): boolean {
  let hasField = false;
  
  function checkNode(n: SyntaxNode) {
    if (n.type.id === AttributeField || n.type.id === IntrinsicField) {
      hasField = true;
      return;
    }
    
    const cursor = n.cursor();
    if (cursor.firstChild()) {
      do {
        checkNode(cursor.node);
      } while (cursor.nextSibling() && !hasField);
    }
  }
  
  checkNode(node);
  return hasField;
}

/**
 * Check if a node contains a value (Static)
 */
function containsValue(node: SyntaxNode): boolean {
  let hasValue = false;
  
  function checkNode(n: SyntaxNode) {
    if (n.type.id === Static) {
      hasValue = true;
      return;
    }
    
    const cursor = n.cursor();
    if (cursor.firstChild()) {
      do {
        checkNode(cursor.node);
      } while (cursor.nextSibling() && !hasValue);
    }
  }
  
  checkNode(node);
  return hasValue;
}

/**
 * Extract text content from a syntax node.
 * Adapted from Tempo's situation.ts
 */
function getNodeText(node: SyntaxNode, text: string): string {
  return text.slice(node.from, node.to);
}

/**
 * Parse a field reference into scope and tag.
 * Adapted from Tempo's logic and the limited parser.
 */
function parseField(field: string): { scope?: string; tag?: string } {
  // Clean up the field text - remove leading dots if present
  const cleanField = field.startsWith('.') ? field.slice(1) : field;
  
  // Check if it's an intrinsic field with colon notation
  for (const intrinsic of INTRINSIC_FIELDS) {
    if (cleanField === intrinsic) {
      if (intrinsic.includes(':')) {
        const [scope, tag] = intrinsic.split(':');
        return { scope, tag };
      } else {
        // Legacy intrinsic without scope prefix
        return { scope: 'intrinsic', tag: intrinsic };
      }
    }
  }

  // Check for scope.tag pattern (only if it's a valid scope)
  const dotIndex = cleanField.indexOf('.');
  if (dotIndex > 0) {
    const potentialScope = cleanField.slice(0, dotIndex);
    const remainingTag = cleanField.slice(dotIndex + 1);

    // Validate scope - only split if it's a valid TraceQL scope
    if (VALID_SCOPES.includes(potentialScope)) {
      return { scope: potentialScope, tag: remainingTag };
    }
  }

  // If no valid scope found, treat the entire field as an intrinsic tag
  // This handles cases like "service.name" which should be intrinsic with tag "service.name"
  return { scope: 'intrinsic', tag: cleanField };
}

/**
 * Parse a value, handling quotes and different types.
 * Adapted from the limited parser.
 */
function parseValue(value: string): string | string[] | null {
  if (!value) {
    return null;
  }

  // Handle quoted strings
  if ((value.startsWith('"') && value.endsWith('"')) || 
      (value.startsWith("'") && value.endsWith("'"))) {
    const unquoted = value.slice(1, -1);
    // Handle escape sequences
    return unquoted.replace(/\\"/g, '"').replace(/\\'/g, "'").replace(/\\\\/g, '\\');
  }

  // Handle multiple values separated by | (for regex operators)
  if (value.includes('|') && !value.startsWith('"') && !value.startsWith("'")) {
    return value.split('|').map(v => v.trim()).filter(v => v.length > 0);
  }

  return value;
}

/**
 * Fallback regex parser for cases where Lezer parser fails due to invalid scopes.
 * Uses the same logic as the limited parser for these edge cases.
 */
function parseWithRegexFallback(expression: string): TraceqlFilter | null {
  // Simple regex to extract field, operator, and value
  const match = expression.match(/^([^=!<>~]+)(>=|<=|!=|=~|!~|=|>|<)(.+)$/);
  if (!match) {
    return null;
  }

  const [, fieldPart, operator, valuePart] = match;
  const field = fieldPart.trim();
  const value = parseValue(valuePart.trim());

  if (!field || !value) {
    return null;
  }

  const { scope, tag } = parseField(field);
  if (!tag) {
    return null;
  }

  return {
    scope,
    tag,
    operator,
    value,
  };
}

/**
 * Helper function to determine if a filter is an intrinsic field.
 * Adapted from Tempo's SearchTraceQLEditor/utils.ts
 */
function isIntrinsic(filter: TraceqlFilter): boolean {
  const intrinsics = [
    'event:name',
    'event:timeSinceStart', 
    'instrumentation:name',
    'instrumentation:version',
    'link:spanID',
    'link:traceID',
    'span:duration',
    'span:id',
    'span:kind',
    'span:name',
    'span:status',
    'span:statusMessage',
    'trace:duration',
    'trace:id',
    'trace:rootName',
    'trace:rootService',
  ].map((fullName) => {
    const [scope, tag] = fullName.split(':');
    return { scope, tag };
  });

  return intrinsics.some((intrinsic) => intrinsic.tag === filter.tag && intrinsic.scope === filter.scope);
}

/**
 * Combine filters with the same scope/tag/operator into single filters with array values.
 * This recreates the original Query Builder structure where multiple values for the same
 * field are represented as a single filter with an array value.
 * 
 * Based on Tempo's SearchTraceQLEditor/utils.ts lines 83-84 in filterToQuerySection:
 * if (Array.isArray(f.value) && f.value.length > 1 && !isRegExpOperator(f.operator!)) {
 *   return `(${f.value.map((v) => `${scopeHelper(f, lp)}${tagHelper(f, filters)}${f.operator}${valueHelper({ ...f, value: v })}`).join(' || ')})`;
 * }
 */
function combineFiltersWithSameField(filters: TraceqlFilter[]): TraceqlFilter[] {
  const filterMap = new Map<string, TraceqlFilter>();

  for (const filter of filters) {
    const key = `${filter.scope}:${filter.tag}:${filter.operator}`;
    
    if (filterMap.has(key)) {
      // Combine with existing filter
      const existing = filterMap.get(key)!;
      if (Array.isArray(existing.value)) {
        existing.value.push(filter.value as string);
      } else {
        existing.value = [existing.value as string, filter.value as string];
      }
    } else {
      // First occurrence of this field/operator combination
      filterMap.set(key, { ...filter });
    }
  }

  return Array.from(filterMap.values());
}

/**
 * Check if there are OR operators between different spansets.
 */
function checkForOrBetweenSpansets(tree: any, query: string): boolean {
  let hasOrOperator = false;
  
  tree.iterate({
    enter: (nodeRef: SyntaxNodeRef) => {
      // Look for Or node type (this would be between spansets)
      if (nodeRef.type.name === 'Or') {
        hasOrOperator = true;
      }
    },
  });
  
  return hasOrOperator;
}

/**
 * Check for other unsupported TraceQL patterns and collect errors.
 */
function checkForUnsupportedPatterns(tree: any, query: string, errors: TraceQLParseError[]): void {
  tree.iterate({
    enter: (nodeRef: SyntaxNodeRef) => {
      // Check for structural operators
      if (['Gt', 'Lt', 'Anc', 'Desc'].includes(nodeRef.type.name)) {
        errors.push({
          type: 'unsupported_structural_operator',
          message: `Structural operator (${nodeRef.type.name.toLowerCase()}) detected. Span relationships will be ignored, only basic filters will be extracted.`,
          query
        });
      }
      
      // Check for pipeline operations
      if (nodeRef.type.name === 'Pipe') {
        errors.push({
          type: 'unsupported_pipeline',
          message: 'Pipeline aggregation detected. Only the filter part will be extracted, aggregation will be ignored.',
          query
        });
      }
      
      // Check for union operators
      if (nodeRef.type.name === 'UnionStructuralOp') {
        errors.push({
          type: 'unsupported_union_operator',
          message: 'Union operator detected. Complex span relationships will be ignored, only basic filters will be extracted.',
          query
        });
      }
    },
  });
}

/**
 * Get the appropriate separator for a filter (: for intrinsics, . for attributes).
 * Adapted from Tempo's SearchTraceQLEditor/utils.ts
 */
export function getScopeSeparator(filter: TraceqlFilter): string {
  return isIntrinsic(filter) ? ':' : '.';
}
